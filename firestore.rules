rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    // Doc /users/{uid} doit exister et contenir "fonction"
    function userDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    function isChefOrCdt() {
      return isSignedIn() && (
        request.auth.token.admin == true ||
        (userDoc().data.fonction in ['chef', 'cdt'])
      );
    }

    // ───────── missions ─────────
    match /missions/{missionId} {

      // lecture: tout utilisateur connecté
      allow read: if isSignedIn();

      // création: chef ou cdt
      // - on n'autorise PAS remoteId à la création (l'app l'ajoute après)
      allow create: if isChefOrCdt()
        && request.resource.data.keys().hasOnly([
          'date','vecteur','pilote1','pilote2','pilote3',
          'destinationCode','description','createdAt','updatedAt'
        ])
        && request.resource.data.date is timestamp
        && request.resource.data.vecteur is string
        && request.resource.data.pilote1 is string
        && (!('pilote2' in request.resource.data) || request.resource.data.pilote2 is string)
        && (!('pilote3' in request.resource.data) || request.resource.data.pilote3 is string)
        && request.resource.data.destinationCode is string
        && (!('description' in request.resource.data) || request.resource.data.description is string)
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      // mise à jour: chef ou cdt
      // - createdAt ne doit pas changer
      // - on autorise à poser/mettre à jour remoteId et updatedAt
      allow update: if isChefOrCdt()
        && request.resource.data.keys().hasOnly([
          'date','vecteur','pilote1','pilote2','pilote3',
          'destinationCode','description','createdAt','updatedAt','remoteId'
        ])
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.date is timestamp
        && request.resource.data.vecteur is string
        && request.resource.data.pilote1 is string
        && (!('pilote2' in request.resource.data) || request.resource.data.pilote2 is string)
        && (!('pilote3' in request.resource.data) || request.resource.data.pilote3 is string)
        && request.resource.data.destinationCode is string
        && (!('description' in request.resource.data) || request.resource.data.description is string)
        && request.resource.data.updatedAt is timestamp
        && (!('remoteId' in request.resource.data) || request.resource.data.remoteId is string);

      // suppression: chef ou cdt
      allow delete: if isChefOrCdt();
    }

  
  	//firebase deploy --only firestore:rules

    // ───────── users ─────────
    match /users/{userId} {
      // lecture: tout user connecté
      allow read: if request.auth != null;

      // write: uniquement par le propriétaire de son doc
      allow write: if request.auth != null
                   && request.auth.uid == userId;
    }

    // ───────── planningEvents ─────────
    match /planningEvents/{eventId} {

      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
        return isSignedIn() && request.auth.token.admin == true;
      }

      // propriétaire = le champ 'user' (UID) du doc correspond à l'UID courant
      function isOwner() {
        return isSignedIn() && resource.data.user == request.auth.uid;
      }

      // lecture: tout user connecté
      allow read: if isSignedIn();

      // création: par un user connecté pour SON propre UID
      // - clés autorisées
      // - types attendus
      // - TWR -> rank obligatoire (1..3)
      // - dateStart <= dateEnd
      allow create: if isSignedIn()
        && request.resource.data.user == request.auth.uid
        && request.resource.data.keys().hasOnly(
             ['user','typeEvent','dateStart','dateEnd','rank','trigramme','createdAt']
           )
        && request.resource.data.user is string
        && request.resource.data.typeEvent is string
        && request.resource.data.dateStart is timestamp
        && request.resource.data.dateEnd is timestamp
        && request.resource.data.dateStart <= request.resource.data.dateEnd
        && (
             (request.resource.data.typeEvent == 'TWR'
               && request.resource.data.rank is int
               && request.resource.data.rank >= 1
               && request.resource.data.rank <= 3)
             || (request.resource.data.typeEvent != 'TWR')
           );

      // mise à jour: admin OU propriétaire
      // - On N'AUTORISE pas le changement de: user, typeEvent, trigramme
      // - Clés autorisées
      // - Champs modifiables:
      //     • non-TWR: dateStart, dateEnd
      //     • TWR    : dateStart, dateEnd, rank (1..3)
      // - dateStart <= dateEnd
      allow update: if (isAdmin() || isOwner())
        && request.resource.data.keys().hasOnly(
             ['user','typeEvent','dateStart','dateEnd','rank','trigramme','createdAt']
           )
        && request.resource.data.user == resource.data.user
        && request.resource.data.typeEvent == resource.data.typeEvent
        && request.resource.data.trigramme == resource.data.trigramme
        && request.resource.data.dateStart is timestamp
        && request.resource.data.dateEnd is timestamp
        && request.resource.data.dateStart <= request.resource.data.dateEnd
        && (
             resource.data.typeEvent == 'TWR'
               ? (
                   // seules ces clés peuvent changer pour TWR
                   request.resource.data.diff(resource.data).changedKeys()
                     .hasOnly(['dateStart','dateEnd','rank'])
                   && request.resource.data.rank is int
                   && request.resource.data.rank >= 1
                   && request.resource.data.rank <= 3
                 )
               : (
                   // non-TWR: seules les dates peuvent changer
                   request.resource.data.diff(resource.data).changedKeys()
                     .hasOnly(['dateStart','dateEnd'])
                 )
           );

      // suppression: admin OU propriétaire
      allow delete: if isAdmin() || isOwner();
    }

    // ───────── organigramme ─────────
    match /organigramme/{docId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null
        && (
          request.auth.token.admin == true
          || get(/databases/$(database)/documents/users/$(request.auth.uid))
               .data.fonction in ['chef','cdt']
        );
    }

	
	
    // ───────── deny all fallback ─────────
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
